#!/usr/bin/env python3

# lektrix
# Copyright (C) 2025  Maurice (mausy5043) Hendrix
# AGPL-3.0-or-later  - see LICENSE

"""Common functions for use with the Home Wizard kWh-meter"""

import datetime as dt
import json
import logging
import sys

import constants as cs
import numpy as np
import pandas as pd
from mausy5043_common import funhomewizard as hwz

LOGGER: logging.Logger = logging.getLogger(__name__)


class WizkWh:
    """Class to interact with the Home Wizard kWh-meter."""

    def __init__(self, debug: bool = False) -> None:
        self.debug: bool = debug
        self.dt_format = cs.DT_FORMAT
        # starting values
        self.ev_elec_in = np.nan
        self.pv_elec_in = np.nan
        self.ev_elec_out = np.nan
        self.pv_elec_out = np.nan
        self.ev_voltage = np.nan
        self.pv_voltage = np.nan
        self.ev_freq = np.nan
        self.pv_freq = np.nan
        self.ev_pf = np.nan
        self.pv_pf = np.nan
        self.list_data: list = []

        # set-up logging
        if debug:
            if len(LOGGER.handlers) == 0:
                LOGGER.addHandler(logging.StreamHandler(sys.stdout))
            LOGGER.level = logging.DEBUG
            LOGGER.debug("Debugging on.")
            self.telegram: list = []

        # process config file
        with open(cs.WIZ_KWH["config"], encoding="utf-8") as _json_file:
            _cfg = json.load(_json_file)
        self.ev_serial: str = _cfg["EV"]["serial"]
        self.ev_token: str = _cfg["EV"]["token"]
        self.pv_serial: str = _cfg["PV"]["serial"]
        self.pv_token: str = _cfg["PV"]["token"]
        self.p1_serial: str = _cfg["P1"]["serial"]
        self.p1_token: str = _cfg["P1"]["token"]

        # NB: mausy5043_common displays device info.
        # connect to the Home Wizard devices
        self.ev_hwe = hwz.MyHomeWizard(
            serial=self.ev_serial, token=self.ev_token, debug=self.debug
        )
        self.pv_hwe = hwz.MyHomeWizard(
            serial=self.pv_serial, token=self.pv_token, debug=self.debug
        )
        self.p1_hwe = hwz.MyHomeWizard(
            serial=self.p1_serial, token=self.p1_token, debug=self.debug
        )
        self.ev_hwe.connect()
        self.pv_hwe.connect()
        self.p1_hwe.connect()

    def get_telegram(self):
        """Fetch data from the devices.

        Returns:
            Nothing
        """
        _ev_data = self.ev_hwe.get_measurement()
        _pv_data = self.pv_hwe.get_measurement()
        _p1_data = self.p1_hwe.get_measurement()

        self.list_data.append(self._translate_telegram([_ev_data, _pv_data, _p1_data]))
        LOGGER.debug(self.list_data)
        LOGGER.debug("*-*")

    def _translate_telegram(self, telegram: list) -> dict:
        """Translate the telegram to a dict.

        kW or kWh are converted to W resp. kW

        Returns:
            (dict): data converted to a dict.
        """
        _ev = telegram[0]
        _pv = telegram[1]
        _p1 = telegram[2]
        self.ev_elec_in = int(_ev.energy_import_kwh * 1000)
        self.pv_elec_in = int(_pv.energy_import_kwh * 1000)
        self.p1_elec_in = int(_p1.energy_import_kwh * 1000)
        self.ev_elec_out = int(_ev.energy_export_kwh * -1000)
        self.pv_elec_out = int(_pv.energy_export_kwh * -1000)
        self.p1_elec_out = int(_p1.energy_export_kwh * -1000)
        self.ev_voltage = int(_ev.active_voltage_v * 10)
        self.pv_voltage = int(_pv.active_voltage_v * 10)
        # not available on P1-dongle w/ KAMSTRUP
        # self.p1_voltage = int(_p1.active_voltage_v * 10)
        self.home_voltage = int((self.ev_voltage + self.pv_voltage) / 2)
        self.ev_freq = int(_ev.active_frequency_hz * 10)
        self.pv_freq = int(_pv.active_frequency_hz * 10)
        # not available on P1-dongle w/ KAMSTRUP
        # self.p1_freq = int(_p1.active_frequency_hz * 10)
        self.home_freq = int((self.ev_freq + self.pv_freq) / 2)

        idx_dt: dt.datetime = dt.datetime.now()
        epoch = int(idx_dt.timestamp())

        return {
            "sample_time": idx_dt.strftime(self.dt_format),
            "sample_epoch": epoch,
            "site_id": "4.2",  # 4.1 used for myenergi data
            "exp": self.p1_elec_out,  # exported to grid
            "imp": self.p1_elec_in,  # imported from grid to home
            "gen": self.pv_elec_out,  # consumed by PV (feeding to battery)
            "gep": self.pv_elec_in,  # generated by PV to home (solar production or from battery)
            "evn": self.ev_elec_out,  # consumed by EV
            "evp": self.ev_elec_in,  # V2H from EV to home
            "v1": self.home_voltage,  # avg voltage in the home
            "frq": self.home_freq,  # avg frequency in the home
        }

    @staticmethod
    def compact_data(data) -> tuple:
        """
        Compact the ten-second data into 15-minute data

        Args:
            data (list): list of dicts containing 10-second data from the electricity meter

        Returns:
            (list): list of dicts containing compacted 15-minute data
        """

        def _convert_time_to_epoch(date_to_convert) -> int:
            return int(pd.Timestamp(date_to_convert).timestamp())

        def _convert_time_to_text(date_to_convert) -> str:
            return str(pd.Timestamp(date_to_convert).strftime(cs.DT_FORMAT))

        df = pd.DataFrame(data)
        df = df.set_index("sample_time")
        df.index = pd.to_datetime(df.index, format=cs.DT_FORMAT, utc=False)

        # resample to monotonic timeline
        df_out = df.resample("15min", label="right").max()
        df_mean = df.resample("15min", label="right").mean()
        # recreate column 'sample_time' that was lost to the index
        df_out["sample_time"] = df.index.to_frame(name="sample_time")
        df_out["sample_time"] = df["sample_time"].apply(_convert_time_to_text)
        # reset 'site_id'
        df_out["site_id"] = 4.2
        # fields 'v1' and 'frq' should be averaged so divide them by 15 here:
        df_out["v1"] = df_mean["v1"].astype(int)
        df_out["frq"] = df_mean["frq"].astype(int)

        # recalculate 'sample_epoch'
        df_out["sample_epoch"] = df["sample_time"].apply(_convert_time_to_epoch)
        result_data = df_out.to_dict("records")  # list of dicts

        df = df[df["sample_epoch"] > np.max(df_out["sample_epoch"])]
        remain_data = df.to_dict("records")

        LOGGER.debug(f"Result: {result_data}")
        LOGGER.debug(f"Remain: {remain_data}\n")
        return result_data, remain_data
